<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WHIP - Web Host Input Protocol</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #input-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #1a1a2e;
            cursor: crosshair;
        }
        #status-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 12px;
            color: white;
            pointer-events: none;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        .status-indicator.connected {
            background-color: #4ade80;
        }
        .status-indicator.disconnected {
            background-color: #ef4444;
        }
        .status-indicator.connecting {
            background-color: #fbbf24;
        }
    </style>
</head>
<body>
    <canvas id="input-canvas" tabindex="0"></canvas>
    <div id="status-overlay">
        <span class="status-indicator disconnected" id="status-dot"></span>
        <span id="status-text">Connecting...</span>
    </div>

    <script>
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        const canvas = document.getElementById('input-canvas');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');

        // Canvas resize handling
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initialize on load

        function updateStatus(status) {
            statusDot.className = 'status-indicator ' + status;
            switch(status) {
                case 'connected':
                    statusText.textContent = 'Connected';
                    break;
                case 'disconnected':
                    statusText.textContent = 'Disconnected';
                    break;
                case 'connecting':
                    statusText.textContent = 'Connecting...';
                    break;
            }
        }

        function connect() {
            updateStatus('connecting');

            // Construct WebSocket URL based on current page location
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                updateStatus('connected');
                reconnectAttempts = 0;
                canvas.focus(); // Auto-focus canvas on connection
            };

            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                // Future: handle server messages
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };

            ws.onclose = function() {
                updateStatus('disconnected');

                // Auto-reconnect with exponential backoff
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 10000);
                    setTimeout(connect, delay);
                }
            };
        }

        // Mouse button mapping function
        function getButtonName(button) {
            switch(button) {
                case 0: return 'left';
                case 1: return 'middle';
                case 2: return 'right';
                default: return 'left';
            }
        }

        // Mouse move event handler
        canvas.addEventListener('mousemove', (e) => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Calculate normalized coordinates (0-1 range)
                const x = e.offsetX / canvas.width;
                const y = e.offsetY / canvas.height;
                ws.send(JSON.stringify({
                    type: 'mouse_move',
                    data: { x, y, timestamp: Date.now() }
                }));
            }
        });

        // Mouse down event handler
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault(); // Prevents text selection start and middle-click auto-scroll
            canvas.focus(); // Ensure keyboard events work after mouse interaction
            if (ws && ws.readyState === WebSocket.OPEN) {
                const x = e.offsetX / canvas.width;
                const y = e.offsetY / canvas.height;
                ws.send(JSON.stringify({
                    type: 'mouse_down',
                    data: { button: getButtonName(e.button), x, y }
                }));
            }
        });

        // Mouse up event handler
        canvas.addEventListener('mouseup', (e) => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const x = e.offsetX / canvas.width;
                const y = e.offsetY / canvas.height;
                ws.send(JSON.stringify({
                    type: 'mouse_up',
                    data: { button: getButtonName(e.button), x, y }
                }));
            }
        });

        // Window mouseup listener (catch releases outside canvas)
        window.addEventListener('mouseup', (e) => {
            // Only send if mouse was pressed inside canvas but released outside
            if (ws && ws.readyState === WebSocket.OPEN && e.target !== canvas) {
                ws.send(JSON.stringify({
                    type: 'mouse_up',
                    data: { button: getButtonName(e.button), x: -1, y: -1 }
                }));
            }
        });

        // Keyboard down event handler
        canvas.addEventListener('keydown', (e) => {
            // Don't capture if Ctrl/Cmd is pressed (allow browser shortcuts)
            if (e.ctrlKey || e.metaKey) {
                return; // Let browser handle Ctrl+C, Cmd+R, etc.
            }

            // Prevent default for navigation keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                 ' ', 'Tab', 'Home', 'End', 'PageUp', 'PageDown'].includes(e.key)) {
                e.preventDefault();
            }

            // Skip if key is being held (auto-repeat)
            if (e.repeat) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'key_down',
                    data: {
                        key: e.key,    // Character value: "a", "Enter", "ArrowUp"
                        code: e.code   // Physical key: "KeyA", "Enter", "ArrowUp"
                    }
                }));
            }
        });

        // Keyboard up event handler
        canvas.addEventListener('keyup', (e) => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'key_up',
                    data: {
                        key: e.key,
                        code: e.code
                    }
                }));
            }
        });

        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Start connection on page load
        connect();
    </script>
</body>
</html>
