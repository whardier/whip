---
phase: 03-macos-control-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/whip/permissions.py
  - src/whip/controller.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Permission check detects whether Accessibility is granted"
    - "Clear error message explains how to grant permissions"
    - "Controller can move mouse to absolute screen coordinates"
    - "Controller can perform left/right/middle mouse clicks"
    - "Controller can press and release keyboard keys"
  artifacts:
    - path: "src/whip/permissions.py"
      provides: "Accessibility permission checking and user instructions"
      exports: ["check_accessibility_permission", "print_permission_instructions"]
    - path: "src/whip/controller.py"
      provides: "pynput wrapper for mouse and keyboard control"
      exports: ["InputController"]
    - path: "pyproject.toml"
      contains: "pynput"
  key_links:
    - from: "src/whip/permissions.py"
      to: "pynput.mouse.Controller"
      via: "test mouse movement to detect permission status"
      pattern: "mouse\\.position"
    - from: "src/whip/controller.py"
      to: "pynput.mouse"
      via: "Controller for mouse operations"
      pattern: "from pynput\\.mouse import"
    - from: "src/whip/controller.py"
      to: "pynput.keyboard"
      via: "Controller for keyboard operations"
      pattern: "from pynput\\.keyboard import"
---

<objective>
Create permission checking and macOS input control modules using pynput.

Purpose: Establish the foundation for controlling macOS mouse and keyboard from Python, with proper permission detection to provide helpful user guidance when Accessibility permissions are missing.

Output:
- src/whip/permissions.py (permission check + instructions)
- src/whip/controller.py (InputController class)
- pyproject.toml updated with pynput dependency
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/macos-input-control.md

# Existing code to integrate with
@src/whip/protocol.py
@src/whip/queue.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permissions module with Accessibility check</name>
  <files>src/whip/permissions.py, pyproject.toml</files>
  <action>
Create src/whip/permissions.py with two functions:

1. `check_accessibility_permission() -> bool`:
   - Create pynput mouse.Controller instance
   - Get current mouse position
   - Attempt to move mouse 1 pixel and back
   - Compare positions - if unchanged, permissions not granted
   - Return True if mouse actually moved, False otherwise
   - Handle any exceptions as False (permission denied)
   - Use small sleep (0.1s) between move and position check

2. `print_permission_instructions()`:
   - Print clear, formatted instructions for granting Accessibility permission
   - Include: System Settings path (Privacy & Security -> Accessibility)
   - Mention that Terminal/IDE running Python needs the permission
   - Note about macOS Sequoia monthly renewal requirement
   - Instruction to restart the server after granting

Add pynput to pyproject.toml dependencies:
```toml
"pynput>=1.8.0",
```

Run `uv sync` after updating pyproject.toml.
  </action>
  <verify>
```bash
# Verify pynput installed
uv run python -c "from pynput.mouse import Controller; print('pynput OK')"

# Verify module imports
uv run python -c "from whip.permissions import check_accessibility_permission, print_permission_instructions; print('imports OK')"

# Type check
uv run pyright src/whip/permissions.py
```
  </verify>
  <done>
- permissions.py exists with check_accessibility_permission() and print_permission_instructions()
- pynput added to pyproject.toml and installed
- Module imports without errors
- Type check passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InputController for mouse and keyboard control</name>
  <files>src/whip/controller.py</files>
  <action>
Create src/whip/controller.py with InputController class:

```python
from pynput.mouse import Button, Controller as MouseController
from pynput.keyboard import Key, Controller as KeyboardController
from Quartz import CGMainDisplayID, CGDisplayPixelsWide, CGDisplayPixelsHigh
```

**Screen size detection:**
- `get_screen_size() -> tuple[int, int]`: Use Quartz APIs to get primary display dimensions
- Cache screen size at init (don't query every event)

**Mouse control methods:**
- `__init__()`: Create MouseController, KeyboardController, cache screen dimensions
- `move_mouse(norm_x: float, norm_y: float)`:
  - Convert normalized (0-1) to absolute pixels: `x = int(norm_x * screen_width)`, `y = int(norm_y * screen_height)`
  - Clamp to screen bounds (0 to width-1, 0 to height-1)
  - Set `self._mouse.position = (x, y)`
- `click(button: str, x: float, y: float)`:
  - First move to position
  - Map button string to pynput Button: "left" -> Button.left, "right" -> Button.right, "middle" -> Button.middle
  - Call `self._mouse.click(button, 1)` for single click
- `mouse_down(button: str, x: float, y: float)`:
  - Move to position, then `self._mouse.press(mapped_button)`
- `mouse_up(button: str, x: float, y: float)`:
  - Move to position, then `self._mouse.release(mapped_button)`

**Keyboard control methods:**
- `key_down(key: str, code: str)`:
  - Try to map `key` to pynput Key enum for special keys (Enter, Tab, Shift, etc.)
  - For regular characters, use the character directly
  - Call `self._keyboard.press(mapped_key)`
- `key_up(key: str, code: str)`:
  - Same mapping logic as key_down
  - Call `self._keyboard.release(mapped_key)`

**Key mapping helper:**
Create `_map_key(key: str) -> Key | str` that handles:
- Special keys: "Enter" -> Key.enter, "Tab" -> Key.tab, "Escape" -> Key.esc
- Arrow keys: "ArrowUp" -> Key.up, "ArrowDown" -> Key.down, etc.
- Modifier keys: "Shift" -> Key.shift, "Control" -> Key.ctrl, "Alt" -> Key.alt, "Meta" -> Key.cmd
- Function keys: "F1" through "F12" -> Key.f1 through Key.f12
- Other special: "Backspace" -> Key.backspace, "Delete" -> Key.delete, " " (space) -> Key.space
- Regular characters: Return as-is (pynput handles single chars)

Note: Use the `key` parameter (character value), not `code` (physical position). This matches user expectations for text input.
  </action>
  <verify>
```bash
# Verify imports work
uv run python -c "from whip.controller import InputController; print('controller OK')"

# Verify screen size detection
uv run python -c "
from whip.controller import InputController
c = InputController()
w, h = c._screen_width, c._screen_height
print(f'Screen: {w}x{h}')
assert w > 0 and h > 0, 'Screen size detection failed'
"

# Type check
uv run pyright src/whip/controller.py
```
  </verify>
  <done>
- controller.py exists with InputController class
- Screen size detection works (returns reasonable dimensions like 1920x1080 or similar)
- Mouse and keyboard controller instances created
- All methods implemented (move_mouse, click, mouse_down, mouse_up, key_down, key_up)
- Key mapping handles special keys and regular characters
- Type check passes
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. Both modules import without errors
2. Type checking passes for both files
3. pynput dependency installed and working
4. Screen size detection returns valid dimensions
5. InputController instantiates successfully
</verification>

<success_criteria>
- src/whip/permissions.py exists with permission check and instructions
- src/whip/controller.py exists with InputController class
- pynput added to pyproject.toml and installed
- All code type-checks without errors
- Modules are ready for integration in Plan 03-02
</success_criteria>

<output>
After completion, create `.planning/phases/03-macos-control-integration/03-01-SUMMARY.md`
</output>
