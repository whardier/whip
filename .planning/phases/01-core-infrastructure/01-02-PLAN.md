---
phase: 01-core-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/whip/main.py
  - src/whip/protocol.py
  - static/index.html
autonomous: true

must_haves:
  truths:
    - "WebSocket connection establishes between browser and server"
    - "Server receives test messages from browser and echoes them back"
    - "Server handles disconnects gracefully without crashing"
  artifacts:
    - path: "src/whip/protocol.py"
      provides: "JSON message protocol types for mouse and keyboard events"
      contains: "MessageType"
    - path: "src/whip/main.py"
      provides: "WebSocket endpoint with echo and disconnect handling"
      contains: "websocket_endpoint"
    - path: "static/index.html"
      provides: "WebSocket client with connection status and test messaging"
      contains: "WebSocket"
  key_links:
    - from: "static/index.html"
      to: "/ws"
      via: "WebSocket connection"
      pattern: 'new WebSocket.*ws'
    - from: "src/whip/main.py"
      to: "src/whip/protocol.py"
      via: "import MessageType"
      pattern: "from.*protocol import"
---

<objective>
Add WebSocket endpoint with JSON message protocol and browser client for bidirectional communication.

Purpose: Enable real-time communication between browser and server - the core transport layer for input events.
Output: Working WebSocket connection with message echo, connection status display, and graceful disconnect handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/fastapi-websocket.md (sections 1, 2, 3, 8)
@.planning/phases/01-core-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define JSON message protocol</name>
  <files>src/whip/protocol.py</files>
  <action>
Create message protocol module with typed message definitions:

1. Create src/whip/protocol.py with:
   - MessageType enum (using StrEnum for JSON serialization):
     - MOUSE_MOVE = "mouse_move"
     - MOUSE_DOWN = "mouse_down"
     - MOUSE_UP = "mouse_up"
     - KEY_DOWN = "key_down"
     - KEY_UP = "key_up"
     - ECHO = "echo"  # For testing
     - PING = "ping"
     - PONG = "pong"

   - Pydantic models (or TypedDict) for message payloads:
     - MouseMoveData: x (float), y (float), timestamp (float)
     - MouseButtonData: button (str: "left"|"right"|"middle"), x (float), y (float)
     - KeyData: key (str), code (str)
     - EchoData: message (str)

   - Generic Message model:
     - type: MessageType
     - data: dict (payload varies by type)
     - Optional timestamp

   - Helper functions:
     - create_message(type: MessageType, data: dict) -> dict
     - parse_message(raw: dict) -> Message

2. Add type hints throughout for pyright compatibility

Per Claude's discretion: Using type + data pattern for message structure (clean separation of concerns, easy to extend).
  </action>
  <verify>
- `uv run python -c "from whip.protocol import MessageType, create_message; print(create_message(MessageType.ECHO, {'message': 'test'}))"` prints valid JSON-serializable dict
- `uv run pyright src/whip/protocol.py` shows no errors
  </verify>
  <done>
Protocol module defines all message types for mouse/keyboard events with proper typing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket endpoint with echo and disconnect handling</name>
  <files>src/whip/main.py, static/index.html</files>
  <action>
Add WebSocket endpoint and update HTML client:

1. Update src/whip/main.py:
   - Import WebSocket, WebSocketDisconnect from fastapi
   - Import protocol types from whip.protocol
   - Add ConnectionManager class (simple for now, single connection):
     - active_connection: WebSocket | None
     - async def connect(websocket: WebSocket)
     - def disconnect()
     - Log connection/disconnection events

   - Add WebSocket endpoint at /ws:
     ```python
     @app.websocket("/ws")
     async def websocket_endpoint(websocket: WebSocket):
         await manager.connect(websocket)
         try:
             while True:
                 data = await websocket.receive_json()
                 # Echo back all messages for now
                 if data.get("type") == "echo":
                     await websocket.send_json(data)
                 elif data.get("type") == "ping":
                     await websocket.send_json({"type": "pong"})
                 else:
                     # Echo with acknowledgment
                     await websocket.send_json({"type": "ack", "received": data["type"]})
         except WebSocketDisconnect:
             manager.disconnect()
             # Log: "Client disconnected"
         except Exception as e:
             # Log error, close cleanly
             manager.disconnect()
     ```

2. Update static/index.html:
   - Add JavaScript WebSocket client:
     - Connect to ws://HOST:9447/ws (use window.location.host for portability)
     - Display connection status (Connected/Disconnected/Connecting)
     - Send test "echo" message on button click
     - Display received messages in a list
     - Handle onopen, onmessage, onerror, onclose events
     - Auto-reconnect on disconnect (simple setTimeout retry)

   - Add minimal UI:
     - Connection status indicator (green/red dot + text)
     - "Send Test Message" button
     - Message log area (shows sent/received messages)

Per Claude's discretion: Simple logging with print() for now (can add structured logging later). Single connection limit (MVP scope).
  </action>
  <verify>
- Start server: `uv run uvicorn whip.main:app --host 0.0.0.0 --port 9447`
- Open http://localhost:9447/static/index.html in browser
- Connection status shows "Connected"
- Click "Send Test Message" - message appears in log with echo response
- Close browser tab - server logs "Client disconnected" without crashing
- Reopen browser - reconnects successfully
  </verify>
  <done>
WebSocket endpoint accepts connections, echoes messages, handles disconnects gracefully. Browser shows connection status and can send/receive test messages.
  </done>
</task>

</tasks>

<verification>
1. WebSocket connects: Browser shows "Connected" status
2. Echo works: Send test message, receive echo response
3. Disconnect handling: Close tab, server continues running, no errors
4. Reconnect works: Reopen browser, connection re-establishes
5. Protocol types: `uv run pyright src/whip/` passes
</verification>

<success_criteria>
- WebSocket connection establishes within 1 second
- Test messages echo correctly with proper JSON structure
- Server handles disconnect without crashing
- Browser displays real-time connection status
- All message types defined in protocol module
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-02-SUMMARY.md`
</output>
