---
phase: 01-core-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/whip/queue.py
  - src/whip/main.py
  - tests/test_queue.py
autonomous: true

must_haves:
  truths:
    - "Event queue deduplicates mouse_move events keeping only the latest position"
    - "Event queue preserves strict FIFO order for keyboard events"
    - "Queue provides visibility into backlog size for monitoring"
  artifacts:
    - path: "src/whip/queue.py"
      provides: "Smart event queue with mouse dedup and keyboard FIFO"
      contains: "EventQueue"
    - path: "tests/test_queue.py"
      provides: "Unit tests verifying queue behavior"
      contains: "test_mouse_dedup"
  key_links:
    - from: "src/whip/main.py"
      to: "src/whip/queue.py"
      via: "import EventQueue"
      pattern: "from.*queue import"
    - from: "src/whip/queue.py"
      to: "src/whip/protocol.py"
      via: "uses MessageType for event classification"
      pattern: "MessageType"
---

<objective>
Implement smart event queue with mouse movement deduplication and keyboard FIFO guarantee.

Purpose: Critical foundation for Phase 3 (macOS control). Queue architecture bridges async WebSocket input to sync pynput output. Mouse dedup prevents lag accumulation; keyboard FIFO guarantees every keystroke is processed in order.
Output: Tested EventQueue class ready for integration with pynput in Phase 3.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-core-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EventQueue with smart deduplication</name>
  <files>src/whip/queue.py</files>
  <action>
Create the smart event queue per user's locked decision:

1. Create src/whip/queue.py with EventQueue class:
   ```python
   import asyncio
   from collections import deque
   from whip.protocol import MessageType

   class EventQueue:
       """
       Smart event queue for bridging async WebSocket to sync pynput.

       Mouse move dedup: When new mouse_move arrives, replace ALL pending
       mouse_move events with the latest position. Only most recent position
       matters to minimize replay lag.

       Keyboard FIFO: Strict order preservation. Every key_down and key_up
       processed in exact order received - no skipping ever.
       """

       def __init__(self):
           self._queue: deque = deque()
           self._latest_mouse_pos: dict | None = None  # Track latest mouse position
           self._has_pending_mouse: bool = False
           self._lock = asyncio.Lock()

       async def put(self, event: dict) -> None:
           """Add event to queue with smart deduplication."""
           async with self._lock:
               event_type = event.get("type")

               if event_type == MessageType.MOUSE_MOVE:
                   # Replace pending mouse position (dedup)
                   self._latest_mouse_pos = event
                   self._has_pending_mouse = True
               else:
                   # Keyboard and other events: strict FIFO
                   # First, flush any pending mouse position
                   if self._has_pending_mouse:
                       self._queue.append(self._latest_mouse_pos)
                       self._has_pending_mouse = False
                       self._latest_mouse_pos = None
                   self._queue.append(event)

       async def get(self) -> dict | None:
           """Get next event from queue. Returns None if empty."""
           async with self._lock:
               # Check for pending mouse position first
               if self._has_pending_mouse:
                   event = self._latest_mouse_pos
                   self._has_pending_mouse = False
                   self._latest_mouse_pos = None
                   return event

               if self._queue:
                   return self._queue.popleft()
               return None

       async def get_blocking(self, timeout: float = 0.1) -> dict | None:
           """Get next event, waiting up to timeout if queue is empty."""
           event = await self.get()
           if event is not None:
               return event

           # Poll with small sleep (avoid busy loop)
           await asyncio.sleep(timeout)
           return await self.get()

       @property
       def backlog_size(self) -> int:
           """Return number of pending events for monitoring."""
           size = len(self._queue)
           if self._has_pending_mouse:
               size += 1
           return size

       @property
       def has_pending(self) -> bool:
           """Check if queue has any pending events."""
           return bool(self._queue) or self._has_pending_mouse
   ```

2. Key behaviors per user decision:
   - Mouse move: ONLY keep latest position, drop all intermediate moves
   - Keyboard: NEVER drop, strict FIFO order
   - Mixed events: When keyboard arrives, flush pending mouse first, then keyboard
   - Backlog visibility: Property for monitoring queue depth

3. Thread-safety: Use asyncio.Lock for concurrent access from WebSocket handler
  </action>
  <verify>
- `uv run python -c "from whip.queue import EventQueue; print('EventQueue imported')"` succeeds
- `uv run pyright src/whip/queue.py` shows no errors
  </verify>
  <done>
EventQueue class implements mouse deduplication and keyboard FIFO with backlog monitoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests and integrate queue with WebSocket handler</name>
  <files>tests/test_queue.py, src/whip/main.py, pyproject.toml</files>
  <action>
Create tests and integrate queue:

1. Update pyproject.toml to add pytest as dev dependency:
   - pytest~=8.0.0
   - pytest-asyncio~=0.24.0

2. Create tests/test_queue.py with comprehensive tests:
   ```python
   import pytest
   from whip.queue import EventQueue
   from whip.protocol import MessageType

   @pytest.mark.asyncio
   async def test_mouse_dedup_keeps_only_latest():
       """Multiple mouse moves should keep only the latest position."""
       q = EventQueue()

       await q.put({"type": MessageType.MOUSE_MOVE, "data": {"x": 0, "y": 0}})
       await q.put({"type": MessageType.MOUSE_MOVE, "data": {"x": 50, "y": 50}})
       await q.put({"type": MessageType.MOUSE_MOVE, "data": {"x": 100, "y": 100}})

       # Should only get the latest position
       event = await q.get()
       assert event["data"]["x"] == 100
       assert event["data"]["y"] == 100

       # Queue should be empty now
       assert await q.get() is None

   @pytest.mark.asyncio
   async def test_keyboard_fifo_order():
       """Keyboard events must preserve exact order."""
       q = EventQueue()

       await q.put({"type": MessageType.KEY_DOWN, "data": {"key": "a"}})
       await q.put({"type": MessageType.KEY_DOWN, "data": {"key": "b"}})
       await q.put({"type": MessageType.KEY_UP, "data": {"key": "a"}})
       await q.put({"type": MessageType.KEY_UP, "data": {"key": "b"}})

       # Must get exact order
       e1 = await q.get()
       e2 = await q.get()
       e3 = await q.get()
       e4 = await q.get()

       assert e1["data"]["key"] == "a" and e1["type"] == MessageType.KEY_DOWN
       assert e2["data"]["key"] == "b" and e2["type"] == MessageType.KEY_DOWN
       assert e3["data"]["key"] == "a" and e3["type"] == MessageType.KEY_UP
       assert e4["data"]["key"] == "b" and e4["type"] == MessageType.KEY_UP

   @pytest.mark.asyncio
   async def test_keyboard_never_dropped():
       """Keyboard events must never be dropped, even with heavy mouse traffic."""
       q = EventQueue()

       # Simulate: mouse move, key down, many mouse moves, key up
       await q.put({"type": MessageType.MOUSE_MOVE, "data": {"x": 0, "y": 0}})
       await q.put({"type": MessageType.KEY_DOWN, "data": {"key": "x"}})
       for i in range(100):
           await q.put({"type": MessageType.MOUSE_MOVE, "data": {"x": i, "y": i}})
       await q.put({"type": MessageType.KEY_UP, "data": {"key": "x"}})

       # Drain queue, counting keyboard events
       keyboard_events = []
       while True:
           event = await q.get()
           if event is None:
               break
           if event["type"] in (MessageType.KEY_DOWN, MessageType.KEY_UP):
               keyboard_events.append(event)

       # Both keyboard events must be present
       assert len(keyboard_events) == 2
       assert keyboard_events[0]["type"] == MessageType.KEY_DOWN
       assert keyboard_events[1]["type"] == MessageType.KEY_UP

   @pytest.mark.asyncio
   async def test_mixed_events_order():
       """Mouse flush happens before keyboard, preserving logical order."""
       q = EventQueue()

       await q.put({"type": MessageType.MOUSE_MOVE, "data": {"x": 10, "y": 10}})
       await q.put({"type": MessageType.KEY_DOWN, "data": {"key": "k"}})

       # Mouse should come first (flushed when keyboard arrived)
       e1 = await q.get()
       e2 = await q.get()

       assert e1["type"] == MessageType.MOUSE_MOVE
       assert e2["type"] == MessageType.KEY_DOWN

   @pytest.mark.asyncio
   async def test_backlog_size():
       """Backlog size should reflect pending events."""
       q = EventQueue()

       assert q.backlog_size == 0

       await q.put({"type": MessageType.MOUSE_MOVE, "data": {"x": 0, "y": 0}})
       assert q.backlog_size == 1  # Pending mouse

       await q.put({"type": MessageType.KEY_DOWN, "data": {"key": "a"}})
       assert q.backlog_size == 2  # Flushed mouse + keyboard

       await q.get()  # Remove one
       assert q.backlog_size == 1
   ```

3. Update src/whip/main.py to integrate queue:
   - Import EventQueue from whip.queue
   - Create global event_queue instance
   - In websocket_endpoint, put received events into queue:
     ```python
     event_queue = EventQueue()

     @app.websocket("/ws")
     async def websocket_endpoint(websocket: WebSocket):
         # ... existing connect logic ...
         try:
             while True:
                 data = await websocket.receive_json()

                 # Echo/ping handling (existing)
                 if data.get("type") == "echo":
                     await websocket.send_json(data)
                 elif data.get("type") == "ping":
                     await websocket.send_json({"type": "pong"})
                 else:
                     # Queue for processing (Phase 3 will consume)
                     await event_queue.put(data)
                     await websocket.send_json({
                         "type": "ack",
                         "received": data.get("type"),
                         "queue_size": event_queue.backlog_size
                     })
         # ... existing exception handling ...
     ```

4. Run `uv sync` to install pytest
  </action>
  <verify>
- `uv run pytest tests/test_queue.py -v` - all tests pass
- `uv run pyright src/whip/` - no type errors
- Start server, send messages via browser, see queue_size in ack responses
  </verify>
  <done>
EventQueue fully tested with mouse dedup and keyboard FIFO. Queue integrated with WebSocket handler, ready for Phase 3 consumption.
  </done>
</task>

</tasks>

<verification>
1. Unit tests: `uv run pytest tests/ -v` passes all 5 queue tests
2. Type checking: `uv run pyright src/whip/` shows no errors
3. Integration: Browser messages show queue_size in acknowledgments
4. Behavior: Send multiple rapid mouse moves - queue size stays low (dedup working)
5. Behavior: Send keyboard events between mouse moves - all keyboard events acknowledged
</verification>

<success_criteria>
- Mouse movement deduplication: 100 rapid mouse moves result in only 1 queued event
- Keyboard FIFO: Events processed in exact order received, none dropped
- Queue monitoring: backlog_size property accurate in real-time
- All tests pass with clear assertions
- Ready for Phase 3 pynput integration
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-03-SUMMARY.md`
</output>
