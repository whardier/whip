---
phase: 04-coordinate-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/whip/repeat.py
  - src/whip/main.py
  - static/index.html
autonomous: true

must_haves:
  truths:
    - "Holding a key causes repeated key presses at consistent rate"
    - "Key repeat starts after initial delay (not immediately)"
    - "Releasing key stops repeat immediately"
    - "Multiple keys can repeat independently"
  artifacts:
    - path: "src/whip/repeat.py"
      provides: "KeyRepeatManager class"
      exports: ["KeyRepeatManager"]
    - path: "src/whip/main.py"
      provides: "Repeat manager integration"
      contains: "repeat_manager"
    - path: "static/index.html"
      provides: "Repeat events forwarded"
      contains: "// Allow repeat events through"
  key_links:
    - from: "static/index.html"
      to: "WebSocket"
      via: "keydown without e.repeat filter"
      pattern: "type.*key_down"
    - from: "src/whip/main.py"
      to: "src/whip/repeat.py"
      via: "KeyRepeatManager.start_repeat and stop_repeat"
      pattern: "repeat_manager\\.(start|stop)_repeat"
---

<objective>
Implement server-side keyboard repeat using asyncio timers.

Purpose: Key repeat should be handled server-side for consistent cross-platform timing. Currently, the frontend filters out all repeat events (`if (e.repeat) return;`), which means holding a key only sends one key_down. This plan adds a KeyRepeatManager that starts repeating key presses after an initial delay when a key is held.

Output: KeyRepeatManager class, frontend repeat filter removed, event consumer integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-coordinate-mapping/04-RESEARCH.md
@src/whip/main.py
@src/whip/controller.py
@static/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KeyRepeatManager class</name>
  <files>src/whip/repeat.py</files>
  <action>
Create a new module `src/whip/repeat.py` containing the KeyRepeatManager class:

1. Class attributes:
   - `_repeat_tasks: dict[str, asyncio.Task]` - maps key to its repeat task
   - `_repeat_delay: float = 0.5` - initial delay before repeat starts (500ms)
   - `_repeat_rate: float = 0.033` - time between repeats (~30Hz)
   - `_controller: InputController` - reference to send key events

2. Constructor:
   - Takes `controller: InputController` parameter
   - Initializes empty `_repeat_tasks` dict

3. Methods:
   - `start_repeat(key: str, code: str) -> None`:
     - Check if key already in `_repeat_tasks` (if so, return - already repeating)
     - Create asyncio task calling `_repeat_key_loop(key, code)`
     - Store task in `_repeat_tasks[key]`

   - `stop_repeat(key: str) -> None`:
     - Check if key in `_repeat_tasks`
     - Cancel the task with `task.cancel()`
     - Remove from dict

   - `async _repeat_key_loop(key: str, code: str) -> None`:
     - Wait `_repeat_delay` seconds (initial delay)
     - Loop forever:
       - Call `self._controller.key_down(key, code)` (simulates press)
       - Wait `_repeat_rate` seconds
     - Wrap in try/except CancelledError to handle cleanup

4. Add type hints and docstrings.

Note: The initial key_down is sent by the event consumer, NOT by this class. This class only handles the repeats after the initial delay.
  </action>
  <verify>
```bash
cd /Users/spencersr/tmp/whip && python -c "from whip.repeat import KeyRepeatManager; print('Import OK')"
cd /Users/spencersr/tmp/whip && uv run pyright src/whip/repeat.py
```
  </verify>
  <done>KeyRepeatManager class exists with start_repeat, stop_repeat methods, passes type checking.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate repeat manager and remove frontend filter</name>
  <files>src/whip/main.py, static/index.html</files>
  <action>
**In src/whip/main.py:**

1. Add import: `from whip.repeat import KeyRepeatManager`

2. Add global variable: `repeat_manager: KeyRepeatManager | None = None`

3. In `startup_event()`, after creating `input_controller`:
   - Create `repeat_manager = KeyRepeatManager(input_controller)`

4. In `event_consumer()`, modify KEY_DOWN and KEY_UP handling:
   - KEY_DOWN: After calling `input_controller.key_down()`, also call `repeat_manager.start_repeat(key, code)`
   - KEY_UP: Call `repeat_manager.stop_repeat(key)` BEFORE calling `input_controller.key_up()` (stop repeat first, then send final key_up)

5. Handle `repeat_manager` being None (permission denied case) - skip repeat calls if None.

**In static/index.html:**

1. Find line 209: `if (e.repeat) return;`
2. Replace with comment: `// Allow repeat events through - server handles repeat timing`
3. The keydown event handler should now send ALL keydown events, including repeats.

Note: Browser repeat events are now ignored by the server (server uses its own timer), but removing the filter ensures the protocol is clean and future-proof.
  </action>
  <verify>
```bash
cd /Users/spencersr/tmp/whip && uv run pyright src/whip/main.py
grep -n "start_repeat\|stop_repeat" /Users/spencersr/tmp/whip/src/whip/main.py
grep -n "repeat" /Users/spencersr/tmp/whip/static/index.html
```
  </verify>
  <done>
- main.py creates KeyRepeatManager on startup
- KEY_DOWN calls start_repeat, KEY_UP calls stop_repeat
- Frontend no longer filters repeat events
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle duplicate repeat events from browser</name>
  <files>src/whip/main.py</files>
  <action>
The browser will now send keydown events during its OS repeat (while user holds key). We need to ignore these and only use our server timer.

In `event_consumer()` KEY_DOWN handling:

1. Track which keys are currently pressed in a set: `_keys_pressed: set[str] = set()`
   - Add this as a module-level variable near `repeat_manager`

2. When KEY_DOWN arrives:
   - If key NOT in `_keys_pressed`:
     - Add key to set
     - Call `input_controller.key_down()`
     - Call `repeat_manager.start_repeat()`
   - If key IS in `_keys_pressed`:
     - This is a browser repeat event - ignore it (don't call key_down or start_repeat again)

3. When KEY_UP arrives:
   - Remove key from `_keys_pressed`
   - Call `repeat_manager.stop_repeat()`
   - Call `input_controller.key_up()`

This ensures:
- First keydown -> press key, start repeat timer
- Browser repeat keydowns -> ignored
- keyup -> stop repeat timer, release key
  </action>
  <verify>
```bash
cd /Users/spencersr/tmp/whip && uv run pyright src/whip/main.py
grep -n "_keys_pressed" /Users/spencersr/tmp/whip/src/whip/main.py
```
  </verify>
  <done>
- _keys_pressed set tracks held keys
- Browser repeat events are ignored (only initial keydown processed)
- Server-side repeat timer handles all repeat presses
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from whip.repeat import KeyRepeatManager"`
2. Type check: `uv run pyright src/whip/`
3. Start server: `uv run uvicorn whip.main:app --host 0.0.0.0 --port 9447`
4. Connect browser, open a text editor on macOS, hold a key - should see repeated characters at ~30Hz after 500ms delay
</verification>

<success_criteria>
- KeyRepeatManager class exists in src/whip/repeat.py
- Holding a key produces repeated characters after initial delay
- Releasing key stops repeat immediately
- Multiple keys can be held and repeat independently
- Type checking passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-coordinate-mapping/04-01-SUMMARY.md`
</output>
