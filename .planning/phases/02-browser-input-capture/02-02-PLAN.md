---
phase: 02-browser-input-capture
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - static/index.html
autonomous: false

must_haves:
  truths:
    - "Keyboard presses captured and sent to server"
    - "Context menu does not appear on right-click"
    - "Text selection does not occur when dragging"
    - "Arrow keys and spacebar do not scroll page"
  artifacts:
    - path: "static/index.html"
      provides: "Complete input capture surface"
      contains: "keydown"
  key_links:
    - from: "static/index.html (canvas keydown)"
      to: "WebSocket send"
      via: "ws.send(JSON.stringify({type: 'key_down', ...}))"
      pattern: "keydown.*ws\\.send"
    - from: "static/index.html (contextmenu)"
      to: "preventDefault"
      via: "e.preventDefault()"
      pattern: "contextmenu.*preventDefault"
---

<objective>
Add keyboard event capture and prevent default browser behaviors (context menu, scrolling, selection) to complete the input capture surface.

Purpose: Enable keyboard control and ensure clean capture without browser interference
Output: Complete browser input capture matching all Phase 2 requirements
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/canvas-input.md
@.planning/phases/02-browser-input-capture/02-01-SUMMARY.md
@src/whip/protocol.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add keyboard event capture</name>
  <files>static/index.html</files>
  <action>
Add keyboard event listeners to the canvas (requires tabindex="0" from Plan 01):

1. **Keyboard down handler:**
   ```javascript
   canvas.addEventListener('keydown', (e) => {
     // Skip if key is being held (auto-repeat)
     if (e.repeat) return;

     if (ws && ws.readyState === WebSocket.OPEN) {
       ws.send(JSON.stringify({
         type: 'key_down',
         data: {
           key: e.key,    // Character value: "a", "Enter", "ArrowUp"
           code: e.code   // Physical key: "KeyA", "Enter", "ArrowUp"
         }
       }));
     }
   });
   ```

2. **Keyboard up handler:**
   ```javascript
   canvas.addEventListener('keyup', (e) => {
     if (ws && ws.readyState === WebSocket.OPEN) {
       ws.send(JSON.stringify({
         type: 'key_up',
         data: {
           key: e.key,
           code: e.code
         }
       }));
     }
   });
   ```

3. **Auto-focus canvas on page load:**
   Add at end of connect() function's onopen handler:
   ```javascript
   canvas.focus();
   ```
   This ensures keyboard events work immediately without requiring a click first.

4. **Focus management on mouse interaction:**
   Already added in Plan 01's mousedown handler (canvas.focus()), but verify it's there.

**Note on e.key vs e.code:** Send both per protocol.py KeyData spec:
- `key`: The character/function (affected by keyboard layout) - for text input
- `code`: The physical key position (layout-independent) - for game controls
Server/macOS will decide which to use based on use case.

**Note on repeat:** Skip key_down events with `e.repeat = true` (auto-repeat from holding key). Phase 3 macOS control will handle key release timing. If we need hold-to-repeat behavior, it should be re-enabled intentionally.
  </action>
  <verify>
With server running and canvas focused:
1. Type a letter (e.g., 'a') - should see key_down then key_up events in server logs
2. Press arrow keys - should see events with key: "ArrowUp", code: "ArrowUp"
3. Press Enter - should see key: "Enter", code: "Enter"
4. Press Shift - should see key: "Shift", code: "ShiftLeft" or "ShiftRight"
5. Hold a key - should see only ONE key_down (repeat filtered)

Verify KeyData structure matches protocol.py: {key: string, code: string}
  </verify>
  <done>
Keyboard events (key_down, key_up) send to server with key and code properties. Auto-repeat is filtered (single key_down per press). Canvas auto-focuses on page load.
  </done>
</task>

<task type="auto">
  <name>Task 2: Prevent default browser behaviors</name>
  <files>static/index.html</files>
  <action>
Add event prevention to create clean capture surface:

1. **Prevent context menu on right-click:**
   ```javascript
   canvas.addEventListener('contextmenu', (e) => {
     e.preventDefault();
   });
   ```

2. **Prevent text selection (drag behavior):**
   ```javascript
   canvas.addEventListener('mousedown', (e) => {
     e.preventDefault(); // Prevents text selection start
     // ... existing mousedown code (focus, send event)
   });
   ```
   Add `e.preventDefault()` at the START of existing mousedown handler.

3. **Prevent arrow keys and spacebar from scrolling page:**
   Update keydown handler to prevent default for navigation keys:
   ```javascript
   canvas.addEventListener('keydown', (e) => {
     // Prevent default for keys that would scroll/navigate
     if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
          'Space', 'Tab', 'Home', 'End', 'PageUp', 'PageDown'].includes(e.key)) {
       e.preventDefault();
     }

     // Skip auto-repeat
     if (e.repeat) return;

     // ... existing key sending code
   });
   ```

4. **Prevent middle-click auto-scroll:**
   The mousedown preventDefault should handle this, but add explicit handling:
   ```javascript
   // In mousedown handler
   if (e.button === 1) {
     e.preventDefault(); // Prevent middle-click auto-scroll
   }
   ```

**Important - Do NOT prevent:**
- Tab key (preventing might break focus flow - but we ARE preventing it since canvas IS the focus target)
- Actually, for this use case, preventing Tab is correct since we want ALL input captured
- F-keys (F1-F12) - let browser handle these for refresh/devtools
- Ctrl/Cmd shortcuts like Ctrl+C, Ctrl+V (browser needs these)

**Refined approach for browser shortcuts:**
```javascript
canvas.addEventListener('keydown', (e) => {
  // Don't capture if Ctrl/Cmd is pressed (allow browser shortcuts)
  if (e.ctrlKey || e.metaKey) {
    return; // Let browser handle Ctrl+C, Cmd+R, etc.
  }

  // Prevent default for navigation keys
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
       ' ', 'Tab', 'Home', 'End', 'PageUp', 'PageDown'].includes(e.key)) {
    e.preventDefault();
  }

  if (e.repeat) return;

  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: 'key_down',
      data: { key: e.key, code: e.code }
    }));
  }
});
```

Note: Space bar key is `' '` (space character) not `'Space'`. The `e.key` for space is `' '`, while `e.code` is `'Space'`.
  </action>
  <verify>
Test each prevented behavior:
1. **Right-click on canvas** - No context menu appears
2. **Click and drag on canvas** - No text selection cursor, no selection highlight
3. **Press arrow keys** - Page does not scroll
4. **Press spacebar** - Page does not scroll
5. **Press Tab** - Focus stays on canvas (not moving to browser UI)
6. **Press Ctrl+R** - Browser refreshes (NOT prevented)
7. **Press Cmd+C** - No error (browser handles it)
8. **Middle-click** - No auto-scroll cursor appears
  </verify>
  <done>
Context menu prevented on right-click. Text selection prevented on drag. Arrow keys, spacebar, Tab, and Page navigation keys do not scroll or change focus. Browser shortcuts (Ctrl/Cmd+key) still work.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete input capture</name>
  <what-built>
Complete browser input capture surface:
- Full-screen canvas filling entire viewport
- Mouse movement tracking (normalized 0-1 coordinates)
- Mouse button detection (left/right/middle)
- Keyboard event capture (key down/up with key and code)
- Default behavior prevention (no context menu, no scrolling, no selection)
- Connection status indicator overlay
  </what-built>
  <how-to-verify>
1. Start server: `uv run uvicorn whip.main:app --host 0.0.0.0 --port 9447`
2. Open http://localhost:9447 in browser
3. Verify canvas fills entire window (no margins, scrollbars)
4. Check connection status shows "Connected" (green dot)

**Mouse tests:**
5. Move mouse around - server should log mouse_move events with x,y in 0-1 range
6. Left click - server logs mouse_down {button: "left"} then mouse_up
7. Right click - NO context menu appears, server logs button: "right"
8. Middle click - NO auto-scroll icon, server logs button: "middle"

**Keyboard tests:**
9. Press letter keys (a, b, c) - server logs key_down/up with key and code
10. Press arrow keys - page does NOT scroll, server receives events
11. Press spacebar - page does NOT scroll, server receives key event
12. Press Ctrl+R or Cmd+R - browser refreshes (not captured)

**Visual check:**
13. Canvas should be dark (#1a1a2e background)
14. Status overlay in top-left corner
15. Crosshair cursor on canvas

If all pass, type "approved". If issues found, describe what failed.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
Phase 2 success criteria (from ROADMAP.md):
1. [x] Blank canvas fills entire browser window (Task 1 from Plan 01)
2. [x] Canvas captures mouse movements and sends coordinates in real-time (Task 2 from Plan 01)
3. [x] Canvas captures left/right/middle mouse clicks and sends button events (Task 2 from Plan 01)
4. [x] Canvas captures keyboard presses and sends key codes (Task 1 from this plan)
5. [x] Context menus and text selection are prevented on canvas (Task 2 from this plan)
6. [x] Connection status indicator shows connected/disconnected state (Task 1 from Plan 01)

All FRONT-* requirements satisfied:
- FRONT-01: Full-screen canvas
- FRONT-02: Mouse movement with offsetX/offsetY (normalized)
- FRONT-03: Mouse clicks (left/right/middle)
- FRONT-04: Keyboard events (key/code)
- FRONT-05: Events sent via WebSocket
- FRONT-06: Default behaviors prevented
- FRONT-07: Connection status indicator
</verification>

<success_criteria>
- Keyboard events send {type: "key_down/up", data: {key: string, code: string}}
- Auto-repeat filtered (one key_down per key press)
- Right-click does not show context menu
- Dragging does not select text
- Arrow keys and spacebar do not scroll page
- Browser shortcuts (Ctrl/Cmd+key) still work
- Human verification confirms all Phase 2 requirements met
</success_criteria>

<output>
After completion, create `.planning/phases/02-browser-input-capture/02-02-SUMMARY.md`
</output>
