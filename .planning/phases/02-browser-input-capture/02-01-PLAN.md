---
phase: 02-browser-input-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - static/index.html
autonomous: true

must_haves:
  truths:
    - "Blank canvas fills entire browser viewport"
    - "Mouse movements captured with canvas-relative coordinates"
    - "Left/right/middle mouse clicks captured and sent"
    - "Connection status visible on canvas"
  artifacts:
    - path: "static/index.html"
      provides: "Full-screen canvas with mouse event capture"
      contains: "canvas"
  key_links:
    - from: "static/index.html (canvas mousemove)"
      to: "WebSocket send"
      via: "ws.send(JSON.stringify({type: 'mouse_move', ...}))"
      pattern: "mousemove.*ws\\.send"
    - from: "static/index.html (canvas mousedown)"
      to: "WebSocket send"
      via: "ws.send(JSON.stringify({type: 'mouse_down', ...}))"
      pattern: "mousedown.*ws\\.send"
---

<objective>
Replace the current debug UI with a full-screen canvas that captures mouse movements and clicks, transmitting them to the server via WebSocket.

Purpose: Transform the browser into an input capture surface for remote control
Output: Working mouse tracking and click detection in browser
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/canvas-input.md
@.planning/phases/01-core-infrastructure/01-02-SUMMARY.md
@static/index.html
@src/whip/protocol.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create full-screen canvas with connection status overlay</name>
  <files>static/index.html</files>
  <action>
Replace the current debug UI in static/index.html with a full-screen canvas:

1. **HTML structure:**
   - Replace body content with: `<canvas id="input-canvas" tabindex="0"></canvas>`
   - Add status overlay div positioned absolutely in top-left corner
   - Status indicator shows connected (green)/disconnected (red)/connecting (yellow) dot + text
   - Add `tabindex="0"` to canvas for keyboard focus (needed for next plan)

2. **CSS for full-screen canvas:**
   ```css
   html, body {
     margin: 0;
     padding: 0;
     width: 100%;
     height: 100%;
     overflow: hidden;
   }
   #input-canvas {
     display: block;
     width: 100%;
     height: 100%;
     background-color: #1a1a2e;  /* Dark background */
     cursor: crosshair;
   }
   ```

3. **Status overlay CSS:**
   - Position: absolute, top: 10px, left: 10px
   - Background: rgba(0,0,0,0.7), padding: 8px 12px, border-radius: 4px
   - Font: small sans-serif, white text
   - Status dot inline with text (10px circle)

4. **Canvas resize handling:**
   - Set canvas.width and canvas.height to window.innerWidth/innerHeight on load
   - Add window resize listener to update canvas dimensions
   - This ensures offsetX/offsetY work correctly (canvas internal vs CSS size)

5. **Keep WebSocket code intact:**
   - Preserve existing connect(), updateStatus(), ws event handlers
   - Remove test button and message log (no longer needed)
   - Status indicator moves from old UI to new overlay

Do NOT add mouse/keyboard event listeners yet - that's Task 2.
  </action>
  <verify>
Start server with `uv run uvicorn whip.main:app --host 0.0.0.0 --port 9447` and open http://localhost:9447 in browser:
- Canvas fills entire viewport (no scrollbars, no margins)
- Status indicator visible in top-left corner
- Status shows "Connected" with green dot when WebSocket connects
- Canvas background is dark (#1a1a2e)
- Resizing window updates canvas properly (no stretching/distortion)
  </verify>
  <done>
Full-screen canvas renders with connection status overlay. Canvas dimensions match window size. WebSocket connects and status displays correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add mouse movement and click event capture</name>
  <files>static/index.html</files>
  <action>
Add mouse event listeners to the canvas element:

1. **Mouse move handler:**
   ```javascript
   canvas.addEventListener('mousemove', (e) => {
     if (ws && ws.readyState === WebSocket.OPEN) {
       // Calculate normalized coordinates (0-1 range)
       const x = e.offsetX / canvas.width;
       const y = e.offsetY / canvas.height;
       ws.send(JSON.stringify({
         type: 'mouse_move',
         data: { x, y, timestamp: Date.now() }
       }));
     }
   });
   ```

2. **Mouse button mapping function:**
   ```javascript
   function getButtonName(button) {
     switch(button) {
       case 0: return 'left';
       case 1: return 'middle';
       case 2: return 'right';
       default: return 'left';
     }
   }
   ```

3. **Mouse down handler:**
   ```javascript
   canvas.addEventListener('mousedown', (e) => {
     canvas.focus(); // Ensure keyboard events work after mouse interaction
     if (ws && ws.readyState === WebSocket.OPEN) {
       const x = e.offsetX / canvas.width;
       const y = e.offsetY / canvas.height;
       ws.send(JSON.stringify({
         type: 'mouse_down',
         data: { button: getButtonName(e.button), x, y }
       }));
     }
   });
   ```

4. **Mouse up handler:**
   ```javascript
   canvas.addEventListener('mouseup', (e) => {
     if (ws && ws.readyState === WebSocket.OPEN) {
       const x = e.offsetX / canvas.width;
       const y = e.offsetY / canvas.height;
       ws.send(JSON.stringify({
         type: 'mouse_up',
         data: { button: getButtonName(e.button), x, y }
       }));
     }
   });
   ```

5. **Window mouseup listener (catch releases outside canvas):**
   ```javascript
   window.addEventListener('mouseup', (e) => {
     // Only send if mouse was pressed inside canvas but released outside
     if (ws && ws.readyState === WebSocket.OPEN && e.target !== canvas) {
       ws.send(JSON.stringify({
         type: 'mouse_up',
         data: { button: getButtonName(e.button), x: -1, y: -1 }
       }));
     }
   });
   ```

**Important:** Use normalized coordinates (0-1 range) per protocol.py MouseMoveData spec. Server will map to screen resolution in Phase 4.

**Performance note:** mousemove fires at high frequency. Server-side queue (from 01-03) handles deduplication, so we can send every event without throttling client-side.
  </action>
  <verify>
With server running, open browser console and check WebSocket traffic:
```javascript
// In browser console, verify events are being sent
// Move mouse - should see mouse_move messages in server log
// Click - should see mouse_down then mouse_up

// Or check server-side:
// Server logs should show queue_size incrementing with mouse activity
```

Test all three button types:
- Left click: button "left"
- Right click: button "right"
- Middle click: button "middle"

Verify coordinates are normalized (between 0 and 1):
- Top-left corner: x~0, y~0
- Bottom-right corner: x~1, y~1
- Center: x~0.5, y~0.5
  </verify>
  <done>
Mouse movements send mouse_move events with normalized x,y coordinates. All three mouse buttons (left/right/middle) send correct mouse_down/mouse_up events. Events transmit in real-time over WebSocket.
  </done>
</task>

</tasks>

<verification>
1. Canvas fills entire viewport with no scrollbars
2. Connection status indicator visible and accurate
3. Mouse movements generate WebSocket messages with normalized coordinates
4. Left/right/middle clicks generate correct button events
5. Server queue receives events (check backlog_size in acknowledgments)
6. No JavaScript errors in browser console
</verification>

<success_criteria>
- Canvas renders full-screen with connection status overlay
- Mouse movements send `{type: "mouse_move", data: {x: 0-1, y: 0-1, timestamp: N}}`
- Mouse clicks send `{type: "mouse_down/up", data: {button: "left/right/middle", x: 0-1, y: 0-1}}`
- Events flow to server and get queued (visible in server logs)
- Requirements satisfied: FRONT-01, FRONT-02, FRONT-03, FRONT-05 (partial), FRONT-07
</success_criteria>

<output>
After completion, create `.planning/phases/02-browser-input-capture/02-01-SUMMARY.md`
</output>
